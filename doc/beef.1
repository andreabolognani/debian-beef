.TH "BEEF" "1" "October 2014" "Beef 1.0.1" ""
.SH NAME
.PP
Beef \- Flexible Brainfuck interpreter
.SH SYNOPSIS
.PP
beef [\f[I]OPTION\f[]]...
\f[I]FILE\f[]
.SH DESCRIPTION
.PP
\f[C]Beef\f[] is a flexible interpreter for the Brainfuck programming
language.
.PP
It can be configured using the options described below, making it
possible to run Brainfuck programs that make assumptions about the
behavior of the interpreter.
.PP
\f[C]Beef\f[] sets no arbitrary limit to the size of the memory tape
used by the program, and allocates memory cells as they are needed.
.SH OPTIONS
.TP
.B \f[C]\-s\f[], \f[C]\-\-store\f[]=\f[I]WHAT\f[]
Choose the value to store in the tape when the end of input is reached.
\f[I]WHAT\f[] defaults to `zero\[aq] (store a zero); other possible
values are `eof\[aq] (store \-1, the value usually assigned to the C
constant EOF) or `same\[aq] (leave the value untouched)
.RS
.RE
.TP
.B \f[C]\-d\f[], \f[C]\-\-enable\-debugging\f[]
Enable debugging support.
By default, debugging instructions are not executed
.RS
.RE
.TP
.B \f[C]\-o\f[], \f[C]\-\-output\-file\f[]=\f[I]FILE\f[]
Write program\[aq]s output to \f[I]FILE\f[]
.RS
.RE
.TP
.B \f[C]\-i\f[], \f[C]\-\-input\-file\f[]=\f[I]FILE\f[]
Read program\[aq]s input from \f[I]FILE\f[]
.RS
.RE
.PP
\f[I]FILE\f[] can be local path or any URI supported by GIO.
If \f[I]FILE\f[] is `\-\[aq] standard input or standard output,
depending on the context, will be used.
.SH BRAINFUCK LANGUAGE
.PP
Brainfuck programs work on a memory tape which contains a virtually
unlimited number of cells; each cell can store a value, which can be
seen either as a character or as an integer number (its ASCII encoding)
depending on the context.
There is a cursor pointing to one of the cells, which is considered to
be the current one; the cursor can be moved around at will.
.PP
A Brainfuck source file is made of a number of Brainfuck instructions;
any symbol which is not an instruction is considered a comment and is
ignored.
There are exceptions to this rule, see below.
.PP
The Brainfuck instructions are:
.TP
.B \f[C]+\f[]
Increase the value in the current cell by one
.RS
.RE
.TP
.B \f[C]\-\f[]
Decrease the value in the current cell by one
.RS
.RE
.TP
.B \f[C]>\f[]
Move the cursor one cell to the right
.RS
.RE
.TP
.B \f[C]<\f[]
Move the cursor one cell to the left
.RS
.RE
.TP
.B \f[C][\f[]
Start a loop.
The instructions contained in the loop are executed as long as the value
of the current cell is not zero
.RS
.RE
.TP
.B \f[C]]\f[]
End a loop started by a \f[C][\f[] instruction
.RS
.RE
.TP
.B \f[C],\f[]
Read a character from the input and store it in che current cell
.RS
.RE
.TP
.B \f[C]\&.\f[]
Write the value of the current cell to the output
.RS
.RE
.TP
.B \f[C]#\f[]
Dump the content of the memory tape for debugging purposes.
This instruction is ignored unless the \f[C]\-\-enable\-debugging\f[]
option is present
.RS
.RE
.PP
If the first line of the source file starts with the magic sequence
\f[C]#!\f[] it is ignored.
This allows you to execute a Brainfuck program without calling
\f[C]Beef\f[] explicitly, like you would do for eg.
a Python program.
.PP
The symbol \f[C]!\f[] has a special meaning to \f[C]Beef\f[]: it marks
the end of a program\[aq]s code and the beginning of its input.
If this symbol is present in the source file, runtime input will be
ignored.
.SH EXAMPLES
.PP
The classic Hello World program could be written in Brainfuck as
.IP
.nf
\f[C]
\ \ \ \ ++++++++++[>+++++++>++++++++++>+++>+<<<<\-]>++.>+.++++++
\ \ \ \ +..+++.>++.<<+++++++++++++++.>.+++.\-\-\-\-\-\-.\-\-\-\-\-\-\-\-.>+.>.
\f[]
.fi
.PP
The following Brainfuck program can be used to replace the
\f[I]cat\f[](1) utility:
.IP
.nf
\f[C]
\ \ \ \ #!/usr/bin/beef
\ \ \ \ ,[.,]
\f[]
.fi
.PP
That\[aq]s of course assuming you don\[aq]t need any of
\f[I]cat\f[](1)\[aq]s fancy commandline options, you have a shell with
working I/O redirection and a sense of humor.
.SH AUTHORS
Andrea Bolognani <eof@kiyuko.org>.
