.TH BEEF 1 "March 2011" "Beef 1.0.0"
.SH NAME
.PP
Beef \[em] Flexible Brainfuck interpreter
.SH SYNOPSIS
.PP
beef [\f[I]OPTION\f[]]\&... \f[I]FILE\f[]
.SH DESCRIPTION
.PP
\f[B]Beef\f[] is a flexible interpreter for the Brainfuck
programming language.
.PP
It can be configured using the options described below, making it
possible to run Brainfuck programs that make assumptions on the
behavior of the interpreter.
.PP
\f[B]Beef\f[] sets no arbitrary limit to the size of the memory
tape used by the program, and allocates cells as they are needed.
.SH OPTIONS
.TP
.B \f[B]-s\f[], \f[B]--store\f[]=\f[I]WHAT\f[]
Choose the value to store in the tape when the end of input is
reached.
WHAT defaults to `zero\[aq] (store a zero); other possible values
are `eof\[aq] (store the value corresponding to EOF) or `same\[aq]
(leave the value untouched)
.RS
.RE
.TP
.B \f[B]-d\f[], \f[B]--enable-debugging\f[]
Enable debugging support.
By default, debugging instructions are not executed
.RS
.RE
.TP
.B \f[B]-o\f[], \f[B]--output-file\f[]=\f[I]FILE\f[]
Write program's output to FILE
.RS
.RE
.TP
.B \f[B]-i\f[], \f[B]--input-file\f[]=\f[I]FILE\f[]
Read program's input from FILE
.RS
.RE
.PP
FILEs can be local, or URIs supported by GIO.
If FILE is `-\[aq] use standard input or standard output, depending
on the context.
.SH BRAINFUCK LANGUAGE
.PP
Brainfuck programs work on a memory tape which contains a virtually
unlimited number of cells; each cell can store a value, which can
be seen either as a character or as an integer number (its ASCII
encoding) depending on the context.
There is a cursor pointing to one of the cells, which is considered
to be the current one; the cursor can be moved around at will.
.PP
A Brainfuck source file is made of a number of Brainfuck
instructions; any symbol which is not an instruction is considered
a comment and is ignored.
There are exceptions to this rule, see below.
.PP
The Brainfuck instructions are:
.TP
.B \f[B]+\f[]
Increase the value in the current cell by one
.RS
.RE
.TP
.B \f[B]-\f[]
Decrease the value in the current cell by one
.RS
.RE
.TP
.B \f[B]>\f[]
Move the cursor one cell to the right
.RS
.RE
.TP
.B \f[B]<\f[]
Move the cursor one cell to the left
.RS
.RE
.TP
.B \f[B][\f[]
Start a loop.
The instructions contained in the loop are executed as long as the
value of the current cell is not zero
.RS
.RE
.TP
.B \f[B]]\f[]
End a loop started by a \f[B][\f[] instruction
.RS
.RE
.TP
.B \f[B],\f[]
Read a character from the input and store it in che current cell
.RS
.RE
.TP
.B \f[B].\f[]
Write the value of the current cell to the output
.RS
.RE
.TP
.B \f[B]#\f[]
Dump the content of the memory tape for debugging purposes.
This instruction is ignored unless the \f[B]--enable-debugging\f[]
option is present
.RS
.RE
.PP
If the first line of the source file starts with the magic sequence
\f[B]#!\f[] it is ignored.
This allows you to execute a Brainfuck program without calling
\f[B]Beef\f[] explicitly, like you would do for eg.
a Python program.
.PP
The symbol \f[B]!\f[] has a special meaning to \f[B]Beef\f[]: it
marks the end of a program's code and the beginning of its input.
If this symbol is present in the source file, runtime input will be
ignored.
.SH EXAMPLES
.PP
The classic Hello World program could be written in Brainfuck as
.PP
\f[CR]
      \ \ \ \ ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.++++++
      \ \ \ \ +..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
\f[]
.PP
The following Brainfuck program can be used to replace the
\f[I]cat\f[](1) utility:
.PP
\f[CR]
      \ \ \ \ #!/usr/bin/beef
      \ \ \ \ ,[.,]
\f[]
.PP
(assuming you don't need any of \f[I]cat\f[](1)'s fancy commandline
options, you have a shell with working I/O redirection and a sense
of humor).
.SH AUTHORS
Andrea Bolognani <eof@kiyuko.org>.

